---
output: 
  html_document:
    theme: null
    css: document.css
---

```{r load, message=FALSE, echo=FALSE}
# set knitr options
source("lib_knitr.R")

# load data
load("data.rda")

# load packages and functions
library("plyr")
library("tidyverse")
library("FactoMineR")
library("printr")
library("lubridate")
library("doParallel")

source("lib_plot.R")        # colour scales and theme
source("lib_data_manip.R")  # summarise tables
source("lib_factorial.R")   # extract and plot info from CAs
source("lib_quantreg.R")    # perform quantile regression
```

# Temporal variability

The time series of the total CPUE (all species pooled) at each site highlights a seasonal variability, with two peaks of high catches around June and in Autumn.

```{r ts_data}
dd <- d0 %>% group_by(site, date) %>% summarise(cpue=sum(cpue)) %>% ungroup()
dd$days <- as.numeric((dd$date - min(dd$date)) / (24*3600))

q <- c(.25, .5, .75, .9)
```

```{r srq}

# srq_fit <- srq(dd$days, dd$cpue,  tau=q, interval="confidence", df=30, se="boot", R=1000)
# 
# srq_fit$date <- min(dd$date) + srq_fit$x * 24 * 3600
# srq_fit$lower[srq_fit$lower < 0] <- 0
# 
# ggplot(srq_fit) +
#   geom_point(aes(x=date, y=cpue), data=filter(dd, cpue < 100), size=1, alpha=0.5, shape=16) +
#   geom_ribbon(aes(x=date, ymin=lower, ymax=higher, fill=tau, alpha=tau)) +
#   scale_alpha_manual(values=c(0., 0.2, 0., 0.2)) +
#   geom_line(aes(x=date, y=fit,colour=tau)) +
#   geom_rug(aes(x=date), filter(dd, cpue > 100), sides="t", alpha=0.5) +
#   geom_rug(aes(x=date), dd, sides="b", alpha=0.1)
```

```{r llrq2}
registerDoParallel(cores=2)
# system.time(llrq_fit <- llrq(dd$days, dd$cpue, tau=q, bw=20, n=200, .parallel=T, .progress="text", smooth=1, interval="conf", se="nid"))
system.time(llrq_fit <- llrq(dd$days, dd$cpue, tau=q, bw=20, n=200, .parallel=T, .progress="text", smooth=1, interval="conf", se="boot", bsmethod="xy", R=1000))
stopImplicitCluster()

llrq_fit$date <- min(dd$date) + llrq_fit$x * 24 * 3600
llrq_fit$lower[llrq_fit$lower < 0] <- 0

# same plot with different data
last_plot() %+% llrq_fit

# TODO do the same per genus/species
```

Highlights both the spring-summer and the autumn peaks.

```{r}
library(stringr)
dd <- d0 %>% filter(species %in% interest_species) %>% group_by(month, species) %>% summarise(mean=mean(cpue))

dd$month <- as.factor(month.abb[dd$month])
ca <- CA(as.multivar(dd, "month"), graph=F)
autoplot(ca, size=1, dimensions=c(1,2))
```

Three main assemblages: 
- Winter, with lower diversity (two main spp)
- Spring and early summer, with few main species quite spread = associated with different months
- Summer and early fall, with high diversity, quite similar among months


## Temporal scales of variability

At which scale do abundances vary the most: do they mostly depend on season, month, etc. We can analyse the temporal scales of variability through a variogram. This computes the difference in CPUE between two successive days (delay = 1 day), two days on successive weeks (delay = 7 days), etc. to test whether the catches are more similar on successive days (autocorrelation) or on the same day in successive months (potential lunar effect), etc.

This is done within each site, for all sampled nights, for the most common species (for which catches are relatively steady). The results below are for all pairwise differences (top) and some summaries --quartiles, median and mean-- (red lines on top, bottom).

```{r}
dd <- d0 %>% filter(species %in% abundant_species) %>% group_by(days_since_start, site) %>% summarise(cpue=sum(cpue)) %>% group_by(site) %>% arrange(days_since_start)

# summary(dd$cpue)
#  Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# 0.000   0.000   0.375   3.736   1.625 899.000

# compute variogram cloud (all pairwise differences)
vario_cloud <- ddply(dd, ~site, function(x) {
  delay <- dist(x$days_since_start)
  # diff <- dist(log1p(x$cpue))
  diff <- dist(x$cpue)
  d <- data.frame(delay=as.numeric(delay), diff=as.numeric(diff))
})
vario_cloud <- filter(vario_cloud, delay < (365*2+10))

# compute average variogram on bins with an ~ equal number of observations
vario <- vario_cloud
breaks <- sort(unique(c(2, 5, quantile(vario$delay, seq(0,1,length.out=30)))))
vario$bins <- cut(vario$delay, breaks, right=F, include.lowest=T)

diffs <- vario %>% group_by(bins) %>% sum_tbl("diff")
delay <- vario %>% group_by(bins) %>% summarise(delay=min(delay))
vario <- full_join(delay, diffs, by="bins")

x_scale <- list(
  scale_x_continuous(
    limits=c(0, 715),
    breaks=c(1, 30, 30*3, 30*6, 365, 365*2),
    labels=c("1 day", "1 month", "3 months", "6 months", "1 year", "2 years"),
    minor=NULL
  ),
  theme(axis.text.x=element_text(angle=35, hjust=1))
)

last_point <- vario[nrow(vario),] %>% select(delay, median, mean) %>% gather(key=label, value=diff, -delay)
ggplot(mapping=aes(x=delay, y=diff)) +
  geom_point(data=vario_cloud, alpha=0.02, shape=16, na.rm=T) +
  geom_path(aes(y=median), data=vario, colour="#F55D5B") +
  geom_path(aes(y=mean), data=vario, colour="#F55D5B", linetype="dashed") +
  geom_label(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3, colour="#F55D5B") +
  x_scale + scale_y_continuous(limits=c(0,100), trans="log1p") +
  labs(x="delay (days)", y="difference in CPUE (log(n+1) scale)")

last_point <- vario[nrow(vario),] %>% select(delay, q25, median, mean, q75) %>% gather(key=label, value=diff, -delay)
ggplot(data=vario, mapping=aes(x=delay)) +
  geom_ribbon(aes(ymin=q25, ymax=q75), alpha=0.5) +
  geom_path(aes(y=median)) +
  geom_path(aes(y=mean), linetype="dashed") +
  geom_text(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3) +
  x_scale + scale_y_continuous(limits=c(0,NA)) +
  labs(x="delay (days)", y="difference in CPUE")
```

Same approacches for catches summarised by level (low, mid, high)
TODO JO review all this part

```{r}
quant <- quantile(dd$cpue, prob = seq(0, 1, length = 100)) 
# we consider that high catches = > 10 cpue, correspond to only 5% of data
# quantile(dd$cpue, 0.80) = 2 larvae
# quantile(dd$cpue, 0.95) = 12 larvae
# quantile(dd$cpue, 0.99) = 50 larvae

high_catches <- dd[which(dd$cpue> quantile(dd$cpue, 0.95)),] 
mid_catches <- dd[which(dd$cpue < quantile(dd$cpue, 0.95)& dd$cpue> quantile(dd$cpue, 0.80)),]
low_catches <- dd[which(dd$cpue < quantile(dd$cpue, 0.80)),]
```

For high catches (5% of data, > 12 cpue)

```{r}
vario_cloud <- ddply(high_catches, ~site, function(x) {
  delay <- dist(x$days_since_start)
  # diff <- dist(log1p(x$cpue))
  diff <- dist(x$cpue)
  d <- data.frame(delay=as.numeric(delay), diff=as.numeric(diff))
})
vario_cloud <- filter(vario_cloud, delay < (365*2+10))

# compute average variogram on bins with an ~ equal number of observations
vario <- vario_cloud
breaks <- sort(unique(c(2, 5, quantile(vario$delay, seq(0,1,length.out=30)))))
vario$bins <- cut(vario$delay, breaks, right=F, include.lowest=T)

diffs <- vario %>% group_by(bins) %>% sum_tbl("diff")
delay <- vario %>% group_by(bins) %>% summarise(delay=min(delay))
vario <- full_join(delay, diffs, by="bins")

x_scale <- list(
  scale_x_continuous(
    limits=c(0, 715),
    breaks=c(1, 30, 30*3, 30*6, 365, 365*2),
    labels=c("1 day", "1 month", "3 months", "6 months", "1 year", "2 years"),
    minor=NULL
  ),
  theme(axis.text.x=element_text(angle=35, hjust=1))
)

last_point <- vario[nrow(vario),] %>% select(delay, median, mean) %>% gather(key=label, value=diff, -delay)
ggplot(mapping=aes(x=delay, y=diff)) +
  geom_point(data=vario_cloud, alpha=0.02, shape=16, na.rm=T) +
  geom_path(aes(y=median), data=vario, colour="#F55D5B") +
  geom_path(aes(y=mean), data=vario, colour="#F55D5B", linetype="dashed") +
  geom_label(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3, colour="#F55D5B") +
  x_scale + scale_y_continuous(limits=c(0,100), trans="log1p") +
  labs(x="delay (days)", y="difference in CPUE (log(n+1) scale)")

last_point <- vario[nrow(vario),] %>% select(delay, q25, median, mean, q75) %>% gather(key=label, value=diff, -delay)
ggplot(data=vario, mapping=aes(x=delay)) +
  geom_ribbon(aes(ymin=q25, ymax=q75), alpha=0.5) +
  geom_path(aes(y=median)) +
  geom_path(aes(y=mean), linetype="dashed") +
  geom_text(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3) +
  x_scale + scale_y_continuous(limits=c(0,NA)) +
  labs(x="delay (days)", y="difference in CPUE")
```

For low catches (80% of data, < 2 cpue)

```{r}
vario_cloud <- ddply(low_catches, ~site, function(x) {
  delay <- dist(x$days_since_start)
  # diff <- dist(log1p(x$cpue))
  diff <- dist(x$cpue)
  d <- data.frame(delay=as.numeric(delay), diff=as.numeric(diff))
})
vario_cloud <- filter(vario_cloud, delay < (365*2+10))

# compute average variogram on bins with an ~ equal number of observations
vario <- vario_cloud
breaks <- sort(unique(c(2, 5, quantile(vario$delay, seq(0,1,length.out=30)))))
vario$bins <- cut(vario$delay, breaks, right=F, include.lowest=T)

diffs <- vario %>% group_by(bins) %>% sum_tbl("diff")
delay <- vario %>% group_by(bins) %>% summarise(delay=min(delay))
vario <- full_join(delay, diffs, by="bins")

x_scale <- list(
  scale_x_continuous(
    limits=c(0, 715),
    breaks=c(1, 30, 30*3, 30*6, 365, 365*2),
    labels=c("1 day", "1 month", "3 months", "6 months", "1 year", "2 years"),
    minor=NULL
  ),
  theme(axis.text.x=element_text(angle=35, hjust=1))
)

last_point <- vario[nrow(vario),] %>% select(delay, median, mean) %>% gather(key=label, value=diff, -delay)
ggplot(mapping=aes(x=delay, y=diff)) +
  geom_point(data=vario_cloud, alpha=0.02, shape=16, na.rm=T) +
  geom_path(aes(y=median), data=vario, colour="#F55D5B") +
  geom_path(aes(y=mean), data=vario, colour="#F55D5B", linetype="dashed") +
  geom_label(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3, colour="#F55D5B") +
  x_scale + scale_y_continuous(limits=c(0,100), trans="log1p") +
  labs(x="delay (days)", y="difference in CPUE (log(n+1) scale)")

last_point <- vario[nrow(vario),] %>% select(delay, q25, median, mean, q75) %>% gather(key=label, value=diff, -delay)
ggplot(data=vario, mapping=aes(x=delay)) +
  geom_ribbon(aes(ymin=q25, ymax=q75), alpha=0.5) +
  geom_path(aes(y=median)) +
  geom_path(aes(y=mean), linetype="dashed") +
  geom_text(aes(y=diff, label=label), data=last_point, hjust=0, nudge_x=5, size=3) +
  x_scale + scale_y_continuous(limits=c(0,NA)) +
  labs(x="delay (days)", y="difference in CPUE")
```

TODO redo the same per species for a few species

These plots can be interpreted as follows:

- from one day to the next (left extreme of the plot), the median difference in CPUE is about 0.5 to 1 fish/CARE/night/site, when the median CPUE is `r median(dd$cpue)`. In other words, the variability is considerably greater than the observation, meaning that, in the vast majority of cases, how much you catch today does not allow to predict how much you will catch tomorrow.
- variance is even higher from one lunar cycle to the next (one month delay).
- a clear ~ 6 months long oscillation is visible, which probably matches the seasonal component highlighted above:
    - high catches in spring-summer and somewhat higher catches in November (6 months between May and Nov),
    - and, more importantly, steady, low catches in Sept-Oct and from Jan to April (6 months between Sept and March).

Overall, catches are as variable in the short term (day to day) as in the long term (month to month or year to year). This, combined with the importance of the large peaks of settlement for the total catch, has important consequences for *sampling strategies*. Indeed, sampling too sparsely in time will likely lead to miss large peaks and change the interpretation of the data completely. Actually, from this analysis, the only safe sampling strategy would seem to be to sample *every single day*.

## Lunar phase variations

```{r results="hide"}
suppressPackageStartupMessages(library("oce", quietly=TRUE))
# get all dates
dates <- sort(unique(d0$date))

# for each date, compute the proportion of the night when the moon is up
moon <- ldply(dates, function(x) {
  # x <- dates[8]

  # go back from noon the previous day, to noon on the day of collection
  interval <- 0.1
  xr <- x - days(1) + seq(12, 36, by=interval)*3600

  # compute position of sun and moon
  sun_alt <- sunAngle(xr, lon=7.31, lat=43.68)$altitude
  moon <- moonAngle(xr, lon=7.31, lat=43.68)
  moon_alt <- moon$altitude

  # detect when sun is down and moon is up
  moon_visible <- (sun_alt < 0) & (moon_alt > 0)
  # compute the number of hours this is the case
  moon_time <- sum(moon_visible) * interval
  
  # compute a moon phase index, based on the proportion illuminated
  # 0 : new moon
  # 1 : next full moon
  # -1 : previous full moon
  # negative : descending
  # positive : ascending
  moon_illum <- mean(moon$illuminatedFraction[sun_alt < 0]) * sign(diff(moon$illuminatedFraction[c(1, length(xr))])) * moon_time
  
  # Compute days since / from new moon
  moon_phase <- mean(moon$phase[sun_alt < 0])%%1
  if(moon_phase < 0.5) {
  moon_phase <- moon_phase + 1
  }
  orbital_period <- 27.32  # orbital period of the moon, in days
  moon_phase <- - round(28 - (moon_phase * orbital_period))

  
    # compute average "moonlight" indexes during that time
  if (moon_time > 0) {
    # visible fraction
    moon_index1 <- mean(moon$illuminatedFraction[moon_visible]) / moon_time
  
    # fraction * diameter * altitude
    moon_index2 <- sum(moon$illuminatedFraction[moon_visible] * moon$diameter[moon_visible] * (moon$altitude[moon_visible]/90))
  } else {
    moon_index1 <- moon_index2 <- 0
  }
  
  data.frame(date=x, moon_time, moon_illum, moon_phase, moon_index1, moon_index2)
}, .progress="none")

# add that to the data
d0m <- left_join(d0, moon, by="date")
dm <- left_join(d, moon, by="date")

# check distribution of effort per moonphase
table(d0m$moon_phase)
#  -14  -13  -12  -11  -10   -9   -8   -7   -6   -5   -4   -3   -2   -1    0    1    2    3    4    5    6    7    8    9   10   11   12   13 
# 1600  900 1000 1300 1300 1600 1900 2400 2200 2800 3400 4401 5700 8402 9900 8800 9400 7700 6600 5500 4100 4400 2900 2200 1900 2500 1800  900 



# # interpolate times of rise and set of celestial bodies
# rise_set <- function(time, altitude) {
#   # time <- ymd("2016-01-01") + hours(0:(24*3))
#   # altitude <- sunAngle(time, lon=7.31, lat=43.68)$altitude
#   xn <- as.numeric(time)
#
#   # detect sign changes in altitude
#   sign_change <- diff(sign(altitude))
#   i <- which(sign_change != 0)
#
#   # interpolate time when body crosses altitude 0
#   d <- data.frame(x1=xn[i], x2=xn[i+1], y1=altitude[i], y2=altitude[i+1])
#   times <- apply(d, 1, function(X) {approx(X[3:4], X[1:2], value)$y})
#   times <- as.POSIXct(times, tz=tz(time), origin="1970-01-01")
#
#   # determine crossing direction
#   direction <- c("set", "rise")[as.numeric(sign_change[i]>0)+1]
#
#   return(data.frame(time=times, direction))
# }
```

If we look at the total number of larvae caught, a large proportion of it is caught around the new moon, as shown below for common species. However the second plot shows that there is still considerable variability in CPUE, even around the new moon, and that it mostly masks the moon-phase signal (the red lines are polynomial regressions of the average CPUE; most of which do not highlight a moon phase influence).

```{r fig.height=5}

# average per lunar day
dplot <- filter(d0m, species %in% interest_species  & cpue < 200) %>% group_by(species, moon_phase) %>% summarize(cpue = mean(cpue))

moon_x <- list(scale_x_continuous(breaks=c(-14, 0, 14), labels=c("\U0099", "\U0098", "\U0099")), theme(axis.text.x=element_text(family="Wingdings 2"), axis.title.x=element_blank()))

# scale between 0 and 1
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
dplot <- ddply(dplot, ~species, function(x){
  x$cpue <- range01(x$cpue)
  x
})

# compute average arrival 
rangeMoon <- dplot %>% group_by(species) %>% summarise(range = weighted.mean(moon_phase, w = cpue))
dplot <- left_join(dplot, rangeMoon, by = "species")
dplot <- arrange(dplot, range)

# order species per mean of arrival during lunar month
unique(dplot$species)
# dplot$species <- factor(x = dplot$species, labels = unique(dplot$species)[c(7, 16, 10, 2:3, 5:6, 8:9, 11:15, 18:19, 4, 17, 1)], levels = unique(dplot$species)[c(7, 16, 10, 2:3, 5:6, 8:9, 11:15, 18:19, 4, 17, 1)])
dplot$species <- factor(x = dplot$species, labels = print(unique(dplot$species)), levels = print(unique(dplot$species)))

# plot distribution of arrival through lunar month
ggplot(filter(dplot, !species %in% "Atherina hepsetus") ) + geom_bar(aes(x=moon_phase, y=cpue), fill="grey30", colour=NA, stat = 'identity') + facet_wrap(~species, ncol=3, scales = "free_y") + moon_x + labs(y="total number of larvae (scaled per species)")


# # density
# ggplot(filter(d0m, species %in% abundant_species)) + geom_density(aes(x=moon_phase, weight=cpue, y=..scaled..), bw=0.05, fill="grey30", colour=NA) + facet_wrap(~species, ncol=3) + moon_x + no_y
#
# # density logged
# ggplot(filter(d0m, species %in% abundant_species)) + geom_density(aes(x=moon_phase, weight=log1p(cpue), y=..scaled..), bw=0.05, fill="grey30", colour=NA) + facet_wrap(~species, ncol=3) + moon_x + no_y
# # does not change much

# ggplot(filter(d0m, species %in% abundant_species), aes(x=moon_phase, y=cpue)) + geom_point(size=1, alpha=0.5) + geom_smooth(se=F, colour="#F55D5B", size=0.5, data=filter(dm, species %in% abundant_species), method="loess") + facet_wrap(~species, ncol=3, scales="free_y") + moon_x + no_y + labs(y="cpue (scaled per species)")

# # log10 transformed
# ggplot(filter(d0m, species %in% abundant_species), aes(x=moon_phase, y=cpue)) + geom_point(size=1, alpha=0.5) + geom_smooth(se=F, colour="red", size=0.5) + facet_wrap(~species, ncol=3) + scale_y_log10() + moon_x
```

Even when we reduce the data to summer months (May to August, included), during which the catches are better overall, the moon phase signal is still mostly indiscernible in instantaneous CPUE.

```{r fig.height=5}
# reduce to summer months
in_summer <- function(x) {
  month(x) %in% 5:8
}
ggplot(filter(d0m, species %in% abundant_species, in_summer(date)), aes(x=moon_phase, y=cpue)) + geom_point(size=1, alpha=0.5) + geom_smooth(se=F, colour="#F55D5B", size=0.5, data=filter(dm, species %in% abundant_species), method="loess") + facet_wrap(~species, ncol=3, scales="free_y") + moon_x + no_y + labs(y="summer cpue (scaled per species)")
```



Another way to look at it is to regress CPUE on moon phase. Using quantile regression, we can focus on the common scenario (median, quantile=0.5), or the higher catches (quantiles > 0.5). We see that the median catch is basically 0 everywhere and that only the 90th percentile (quantile=0.9) starts to respond to moon phase.



```{r fig.height=4}
suppressPackageStartupMessages(library("quantreg", quietly=TRUE))

# select data: common species, in summer, without extreme Spicara
dd <- filter(d0m, species %in% interest_species, !species %in% "Atherina hepsetus", in_summer(date), cpue < 250) %>% group_by(species, moon_phase) %>% summarize(cpue = mean(cpue))

# standardize cpue per species (each species gets the same weight)
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
dd <- ddply(dd, ~species, function(x){
  x$cpue <- range01(x$cpue)
  x
})

# only consider distance to the new moon, irrespective of direction
dd$moon_phase <- abs(dd$moon_phase)

# # plot according to various moon related variables
# ggplot(dd) + geom_point(aes(x=moon_time, y=cpue))
# ggplot(dd) + geom_point(aes(x=moon_phase, y=cpue))
# ggplot(dd) + geom_point(aes(x=moon_index1, y=cpue))
# ggplot(dd) + geom_point(aes(x=moon_index2, y=cpue))


quantiles <- c(0.25, 0.5, 0.75, 0.9)

# Compute rql for all quantiles
qpred <- rql(cpue ~ moon_phase, tau=quantiles, data=dd)

# check significance of the regression curves
summary.rql(qpred, se="boot", R=1000, bsmethod="xy")


# new data for prediction
x <- seq(0, 14, length.out=14)
new <- data.frame(moon_phase=x)
qpreds <- predict.rql(qpred, new = new, interval="confidence")
qpreds$moon_phase <- rep(x, times = length(unique(quantiles)))
# Convert tau to factor 
qpreds$quantile <- factor(qpreds$tau)

# plot the result
ggplot(mapping=aes(x=moon_phase)) +
  geom_point(aes(y=cpue), data=dd, alpha=0.5) +
  geom_ribbon(aes(ymin=lower, ymax=higher, fill=quantile), data=qpreds, alpha=0.3) +
  geom_path(aes(y=fit, colour=quantile), data=qpreds) + scale_color_discrete("Quantile", labels = c(expression("0.25"^"°"), expression("0.5"^"***"), expression("0.75"^"***"), expression("0.9"^"***"))) + scale_fill_discrete("Quantile", labels = c(expression("0.25"^"°"), expression("0.5"^"***"), expression("0.75"^"***"), expression("0.9"^"***"))) +
  # scale_colour_brewer(palette="Reds") + scale_fill_brewer(palette="Reds") +
  scale_y_continuous("CPUE (scaled per species)") +
  scale_x_continuous("Moon phase", breaks=c(0, 7, 14), labels=c("\U0098", "\U00BA", "\U0099")) +
  theme(axis.text.x=element_text(family="Wingdings 2"),legend.text.align = 0) 



```

So, overall, we observe a significant influence of the moon, with higher catches around the new moon for all quantiles, the influence being higher for higher quantiles : highest catches systematically occur around the new moon, even more than average catches. 


## Seasonal variations

Unsurprisingly, the catch is very seasonal, with higher catches from May to mid-September and another small increase around November. NB: the two points with very high catches of *S smaris* occurred in June; they were removed from the plot.

```{r}
dd <- d0 %>% group_by(date, yday, year, site) %>% summarise(cpue=sum(cpue))
dd$fake_date <- ymd("2014-01-01") + days(dd$yday)

q <- c(.25, .5, .75, .9)

# srq_fit <- srq(dd$fake_date, dd$cpue, tau=q, interval="confidence", df=30, se="boot", R=1000)
# 
# srq_fit$fake_date <- srq_fit$x
# srq_fit$lower[srq_fit$lower < 0] <- 0
# 
# ggplot(srq_fit) +
#   geom_point(aes(x=fake_date, y=cpue), data=filter(dd, cpue < 100), size=1, alpha=0.5, shape=16) +
#   geom_ribbon(aes(x=fake_date, ymin=lower, ymax=higher, fill=tau, alpha=tau)) +
#   scale_alpha_manual(values=c(0., 0.2, 0., 0.2)) +
#   geom_line(aes(x=fake_date, y=fit,colour=tau)) +
#   geom_rug(aes(x=fake_date), filter(dd, cpue > 100), sides="t", alpha=0.5) +
#   geom_rug(aes(x=fake_date), dd, sides="b", alpha=0.1) + scale_x_date("month", date_breaks="1 month", date_labels="%b")
```

```{r llrq}
registerDoParallel(cores=2)
# system.time(llrq_fit <- llrq(dd$fake_date, dd$cpue, tau=q, bw=20, n=200, .parallel=T, .progress="text", smooth=1, interval="conf", se="nid"))
system.time(llrq_fit <- llrq(dd$yday, dd$cpue, tau=q, bw=20, n=200, .parallel=T, .progress="text", smooth=1, interval="conf", se="boot", bsmethod="xy", R=1000))
stopImplicitCluster()

llrq_fit$fake_date  <- ymd("2014-01-01") + llrq_fit$x
llrq_fit$lower[llrq_fit$lower < 0] <- 0

# same plot with different data
ggplot(llrq_fit) +
  geom_point(aes(x=fake_date, y=cpue), data=filter(dd, cpue < 100), size=1, alpha=0.5, shape=16) +
  geom_ribbon(aes(x=fake_date, ymin=lower, ymax=higher, fill=tau, alpha=tau)) +
  scale_alpha_manual(values=c(0., 0.2, 0., 0.2)) +
  geom_line(aes(x=fake_date, y=fit,colour=tau)) +
  geom_rug(aes(x=fake_date), filter(dd, cpue > 100), sides="t", alpha=0.5) +
  geom_rug(aes(x=fake_date), dd, sides="b", alpha=0.1) + scale_x_date("month", date_breaks="1 month", date_labels="%b")
```


## Synchronicity among years

Time arrival anomaly => see 3.Spatial.Rmd

At species level, the time of arrival has consistent seasonality across years but can vary of a few weeks from year to year.

```{r fig.height=7}
# dd <- d0 %>% filter(year != 2016, species %in% abundant_species) %>% group_by(yweek, year, species) %>% summarise(cpue=mean(cpue))
# 
# # create a fake date coordinate
# dd$fake_date <- ymd("2014-01-01") + weeks(dd$yweek)
# 
# # rescale per species and year
# dd <- dd %>% group_by(species, year) %>% mutate(scaled_cpue=cpue/max(cpue))
# dd$scaled_cpue[is.na(dd$scaled_cpue)] <- 0  # when max = 0
# 
# # order species by average/first date of arrival
# order <- dd %>%
#   group_by(species) %>%
#   filter(cpue > median(cpue)) %>% 
#   summarise(avg_date=weighted.mean(yweek, scaled_cpue), first_date=min(yweek)) %>%
#   arrange(first_date)
# 
# # rename species for display
# order$species_abbr <- abbrev_sp(order$species, n=5)
# 
# # force order by time of arrival
# dd$species_abbr <- factor(dd$species, levels=order$species, labels=order$species_abbr)
# 
# ggplot(dd) +
#   geom_path(aes(x=fake_date, y=scaled_cpue, colour=year)) +
#   facet_grid(species_abbr~.) +
#   scale_x_date(date_breaks="1 month", date_labels="%b", minor_breaks=NULL) +
#   labs(y="cpue (scaled per species and year)") + no_y


# Do it with points instead of path
dd <- d0 %>% filter(year != 2016) %>% group_by(yweek, year, species) %>% summarise(cpue=mean(cpue))

# rescale per species and year
dd <- dd %>% group_by(species, year) %>% mutate(scaled_cpue=cpue/max(cpue))
dd$scaled_cpue[is.na(dd$scaled_cpue)] <- 0  # when max = 0

# order species by average/first date of arrival
order <- dd %>%
  group_by(species) %>%
  filter(cpue > median(cpue)) %>% 
  summarise(avg_date=weighted.mean(yweek, scaled_cpue), first_date=min(yweek)) %>%
  arrange(first_date)

# rename species for display
order$species_abbr <- abbrev_sp(order$species, n=5)
order <- filter(order, !species_abbr == ". ")

# force order by time of arrival
dd$species_abbr <- factor(dd$species, levels=rev(c(order$species[c(5, 7:length(order$species))], order$species[c(1, 4, 2, 3, 6)])), labels=rev(c(order$species_abbr[c(5, 7:length(order$species_abbr))], order$species_abbr[c(1, 4, 2, 3, 6)])))

# Change cpue = 0 to NA 
dd$scaled_cpue[which(dd$scaled_cpue == 0)] <- NA

#  Remove unidentified species
dd <- filter(dd, !is.na(species))

# plots
ggplot(dd) +
  geom_point(aes(x=yweek, y=species_abbr, size = scaled_cpue)) +
  # scale_x_date(date_breaks="1 month", date_labels="%b", minor_breaks=NULL) +
  labs(y="CPUE (scaled per species)") + scale_size_area("CPUE", max_size = 5) + scale_x_continuous("", breaks = seq(1, 48, length = 12), labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")) + theme(axis.text.y = element_text(face="italic"))




```


## Abundance among years

The effort varied quite a lot among years.

```{r}
effort %>% mutate(year=lubridate::year(date)) %>% filter(year != 2016) %>% group_by(year) %>% summarise(n_nights_sampled=length(unique(date)), n_CARE_fished=sum(n_gear))
```

In total CPUE, pooling all taxa together, the catch seems similar over the years, with possibly a shift towards higher catches in 2014 and 2015. 

```{r}
dd <- d0 %>% filter(year != 2016, year != 2012) %>% group_by(date, year, site) %>% summarise(cpue=sum(cpue))

ggplot(dd, aes(x=year, y=cpue)) + geom_violin(na.rm=T) + geom_point(alpha=0.2, size=1) + scale_y_continuous(trans="log10")

# Or boxplot, easier to check for differences
ggplot(dd, aes(x=year, y=cpue)) + geom_boxplot(na.rm=T) + geom_point(alpha=0.2, size=1) + scale_y_continuous(trans="log10")

```

Pairwise aovq test pvalues
```{r warning=FALSE}

dd <- d0 %>% filter(!year == 2016, !year == 2012) %>% group_by(date, year, site) %>% summarise(cpue=sum(cpue))
dd$year <- factor(dd$year, levels = c(2013, 2014, 2015))


test <- aovq(cpue ~ year, tau=c(0.25, 0.5, 0.75, 0.9), data=dd)

pw <- suppressMessages(pairwise.aovq(dd$cpue, dd$year, tau=c(0.25, 0.5, 0.75, 0.9), R=1000))
# plot
(pw <- ldply(pw, function(x) {
  # x <- pw$`0.9`
  x <- reshape2::melt(x$p.value)
  x$Var1 <- factor(x$Var1, levels=levels(dd$year))
  x$Var2 <- factor(x$Var2, levels=levels(dd$year))
  x$signif <- round(x$value, 2) <= 0.05
  # x <- data.frame(x)
  return(x)
}))

```


```{r}
ggplot(pw) + geom_point(aes(Var1, Var2, shape=signif, colour=signif), na.rm=T) + theme(axis.text.x = element_text(angle=30, hjust=1), axis.title=element_blank()) + facet_wrap(~.id, ncol=1)
```


## Species composition among years

When inspecting the dynamics per species the characteristic year-species couples are:

- 2012: *A hepsetus*
- 2013: *S smaris*
- 2014: *B boops*, *D annularis*, *O melanuara*

```{r fig.height=5}
dd <- d0 %>% filter(year != 2016, year != 2012, species %in% interest_species) %>% group_by(year, species) %>% summarise(mean=mean(cpue))

# relative abundance
# ggplot(dd) + geom_bar(aes(x=year, y=mean), stat="identity") + facet_wrap(~species, scales="free_y") + theme(axis.text.x=element_text(angle=30, hjust=1))

# just make the plot cleaner by pre-computing the relative abundances
ddr <- dd %>% group_by(species) %>% mutate(mean=mean/max(mean))
ggplot(ddr) +
  geom_bar(aes(x=year, y=mean), stat="identity", width=0.75) +
  facet_wrap(~species, ncol=3) +
  scale_y_continuous("relative cpue", breaks=c(0, 0.5, 1)) +
  theme(axis.text.x=element_text(angle=30, hjust=1), axis.text.y=element_blank(), axis.ticks.y=element_blank())

ca <- CA(as.multivar(dd, x.var="year"), graph=F)
autoplot(ca)

```


Differences in species composition are observed between years. 2012, 2013, 2014 are characterized by some species (2012 = *A hepsetus*, 2013 = *S smaris*, 2014 = *B boops*, *D annularis*, *O melanuara*).

These differences could be due to a different sampling effort. For example, 2012 is characterized by A.hepsetus maybe because sites sampled in 2012 have essentially *A.hepsetus*.

However, years 2013 2014 have the same (or very similar) sampling effort (in terms of sites sampled).

2013 : All sites except La Ciotat, Cassis, Carry, Les Embiez
2014 : All sites except La Ciotat, Cassis
2015 : Only Embiez, Ciotat, Cassis, Marseille, Villefranche.

So difference between years in species composition is not due to difference in sampling sites. 


## Synchonicity among years 

Time arrival per year

```{r}

head(d)
dd <- d %>% filter(species %in% interest_species) %>% group_by(date, year, yday, yweek, site, species) %>% summarise(cpue=sum(cpue)) %>% ungroup()

dd <- filter(dd, cpue!=0)

## Check time of arrival by species to identify winter species
ggplot(dd) +
  geom_histogram(aes(x=yweek),binwidth=1) +
  #geom_histogram(aes(x=yweek, weight=cpue),binwidth=1) +
  geom_density(aes(x=yweek, y=..count..)) +
  facet_wrap(~species, ncol=3)+geom_vline(xintercept = 0,linetype="dashed") + xlab("")

#-----------

## Select winter species and choice a date to start the larvae arrival period
winter <- rbind(dd[which(dd$species=="Sarpa salpa"),], dd[which(dd$species=="Pagellus acarne"),])

winter$fake_date <- "2012-10-01"


##Modify day and week according to this new date

winter$shift_day <- round(as.double(difftime(strptime(winter$date, format = "%Y-%m-%d"),strptime(winter$fake_date, format = "%Y-%m-%d"),units="days")),0)
winter$shift_week <- round(as.double(difftime(strptime(winter$date, format = "%Y-%m-%d"),strptime(winter$fake_date, format = "%Y-%m-%d"),units="weeks")),0)

winter$season <- "2012-2013"
winter$season[which(winter$shift_day>365 & winter$shift_day<731)] <- "2013-2014"
winter$season[which(winter$shift_day>=731 & winter$shift_day<1096)] <- "2014-2015"
winter$season[which(winter$shift_day>=1096)] <- "2015-2016"

winter$shift_day <- winter$shift_day%%365
winter$shift_week <- winter$shift_week%%52


## So if we remove the season 2015-2016 (because of not data in begging 2016) we can
## consider 2012-2013 = 2012 season, 2013-2014 = 2013 season, 2014-2015 = 2014 season
winter$fake_year <- NA
winter$fake_year[which(winter$season=="2012-2013")] <- "2013"
winter$fake_year[which(winter$season=="2013-2014")] <- "2014"
winter$fake_year[which(winter$season=="2014-2015")] <- "2015"
winter <- winter %>% filter(!is.na(fake_year)) %>% ungroup()
winter <- select(winter, year=fake_year, species, site, yweek=shift_week, cpue)

```

2012 = only species which recruit in summer
2013 = winter species (season 2012-2013) + summer species of 2013
2014 = winter species (season 2013-2014) + summer species of 2014
2015 = winter species (season 2015-2016) + summer species of 2015

```{r}

summer <- dd %>% filter(species %in% interest_species) %>% filter(species != c("Sarpa salpa", "Pagellus acarne")) %>% ungroup()
samples <- summer

#Compute the mean arrival week by species/sites/year
ref_detailed <- samples %>% group_by(species,site,year) %>% summarise(ref_week_det=round(weighted.mean(yweek, cpue),0))
ref_sp <- ref_detailed %>% group_by(species) %>% summarise(ref_week_sp = round(mean(ref_week_det),0))


#Join the two data.frame to comute lag time for each site
lag <- left_join(ref_detailed, ref_sp, by=c("species"))
lag$lag_week <- lag$ref_week_det - lag$ref_week_sp


#  Remove 2012 because not full
lag <- filter(lag, !year == 2012)

ggplot(lag) +
  geom_histogram(aes(x=lag_week),binwidth=1) +
  geom_density(aes(x=lag_week, y=..count..)) +
  facet_wrap(~year, ncol=1)+geom_vline(xintercept = 0,linetype="dashed") + xlab("")

#Compute mean and median lag
descriptive_stats <- lag %>%
  group_by(year) %>%
  summarise(stats=str_c(round(mean(lag_week),2), "±", round(sd(lag_week),1)), median=median(lag_week))

suppressWarnings (test <- lag %>% group_by(year) %>% do(glance(wilcox.test(.$lag_week,mu = 0,alternative = "two.sided"))))

# make a nice table with both
left_join(descriptive_stats, select(test, statistic, p.value), by="year") %>% ungroup()
# A tibble: 3 × 5
#     year     stats median statistic p.value
#   <fctr>     <chr>  <dbl>     <dbl>   <dbl>
# 1   2013  -0.2±6.1    0.5      1840 0.52060
# 2   2014 -1.24±6.7   -1.0      1894 0.00966
# 3   2015 -2.09±5.2   -2.0       234 0.00016



# Time arrival per year and topography

samples <- summer
# join with topography
samples <- left_join(samples, select(sites, site, topography))

#Compute the mean arrival week by species/sites/year
ref_detailed <- samples %>% group_by(species,site,topography,year) %>% summarise(ref_week_det=round(weighted.mean(yweek, cpue),0))
ref_sp <- ref_detailed %>% group_by(species, topography) %>% summarise(ref_week_sp = round(mean(ref_week_det),0))


#Join the two data.frame to comute lag time for each site
lag <- left_join(ref_detailed, ref_sp, by=c("species", "topography"))
lag$lag_week <- lag$ref_week_det - lag$ref_week_sp


#  Remove 2012 because not full
lag <- filter(lag, !year == 2012)

ggplot(lag) +
  geom_histogram(aes(x=lag_week),binwidth=1) +
  geom_density(aes(x=lag_week, y=..count..)) +
  facet_wrap(year~topography, ncol=2)+geom_vline(xintercept = 0,linetype="dashed") + xlab("")

#Compute mean and median lag
descriptive_stats <- lag %>%
  group_by(year, topography) %>%
  summarise(stats=str_c(round(mean(lag_week),2), "±", round(sd(lag_week),1)), median=median(lag_week))


suppressWarnings (test <- lag %>% group_by(year, topography) %>% do(glance(wilcox.test(.$lag_week,mu = 0,alternative = "two.sided"))))


# make a nice table with both
left_join(descriptive_stats, select(test, statistic, p.value), by=c("year", "topography")) %>% ungroup()
# # A tibble: 6 × 6
#     year   topography     stats median statistic p.value
#   <fctr>       <fctr>     <chr>  <dbl>     <dbl>   <dbl>
# 1   2013 Gulf of Lion -0.14±6.7      1       364  0.1342
# 2   2013 Ligurian sea -0.28±5.2      0       540  0.6189
# 3   2014 Gulf of Lion -0.98±5.1     -1       298  0.1310
# 4   2014 Ligurian sea -1.26±7.3     -1       661  0.0904
# 5   2015 Gulf of Lion  -1.4±5.7     -2        83  0.0021
# 6   2015 Ligurian sea -1.83±5.8     -1        86  0.1819


# Time arrival per year and site

samples <- summer
# join with topography
samples <- left_join(samples, select(sites, site))

#Compute the mean arrival week by species/sites/year
ref_detailed <- samples %>% group_by(species,site,year) %>% summarise(ref_week_det=round(weighted.mean(yweek, cpue),0))
ref_sp <- ref_detailed %>% group_by(species, site) %>% summarise(ref_week_sp = round(mean(ref_week_det),0))


#Join the two data.frame to comute lag time for each site
lag <- left_join(ref_detailed, ref_sp, by=c("species", "site"))
lag$lag_week <- lag$ref_week_det - lag$ref_week_sp


#  Remove 2012 because not full
lag <- filter(lag, !year == 2012)

ggplot(lag) +
  geom_histogram(aes(x=lag_week),binwidth=1) +
  geom_density(aes(x=lag_week, y=..count..)) +
  facet_wrap(site~year, ncol=3)+geom_vline(xintercept = 0,linetype="dashed") + xlab("")

#Compute mean and median lag
descriptive_stats <- lag %>%
  group_by(site, year) %>%
  summarise(stats=str_c(round(mean(lag_week),2), "±", round(sd(lag_week),1)), median=median(lag_week))


suppressWarnings (test <- lag %>% group_by(site, year) %>% do(glance(wilcox.test(.$lag_week,mu = 0,alternative = "two.sided"))))


# make a nice table with both
left_join(descriptive_stats, select(test, statistic, p.value), by=c("site", "year")) %>% ungroup()
# # A tibble: 26 × 6
#      year          site     stats median statistic p.value
#    <fctr>        <fctr>     <chr>  <dbl>     <dbl>   <dbl>
# 1    2013       Leucate      -2±8    0.0      25.0   0.837
# 2    2013  Port Vendres     0±1.3    0.0       5.0   1.000
# 3    2013          Agde     0±1.2    0.0       5.0   1.000
# 4    2013     Marseille     0±4.7    0.0       5.0   1.000
# 5    2013     Port-Cros   0.1±1.1    0.0       8.5   0.890
# 6    2013  Villefranche -0.56±3.6    0.0      13.5   1.000
# 7    2013     Bonifacio -0.57±1.5    0.0       2.5   0.424
# 8    2013 Saint Florent -1.31±2.6    0.0       6.5   0.121
# 9    2013        Bastia  -0.2±6.8    0.0      18.0   0.632
# 10   2014       Leucate -2.21±4.4   -1.5      11.5   0.033


```

